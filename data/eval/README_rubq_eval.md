rubq_eval.jsonl — описание eval-датасета
1. Назначение файла

rubq_eval.jsonl — это единый eval-датасет для оценки Retrieval-Augmented Generation (RAG) системы на русском языке.

Он используется для:

оценки качества retrieval (Recall@k, MRR@k),

последующей оценки качества ответов (EM, Token F1),

честного сравнения разных вариантов retrieval (BM25 / Dense / Cross-Encoder / Coverage-aware),

анализа ошибок и подготовки reward-функций для multi-step / RL.

Файл является статичным эталоном (ground truth) и не меняется при изменении моделей или пайплайна.

2. Источники данных

Eval-датасет собран на основе публичных датасетов:

2.1 Корпус документов

Источник: kaengreg/rubq (subset corpus)

Содержимое: статьи Википедии на русском языке

Использование в проекте:

из этого корпуса строятся BM25 и FAISS индексы,

статьи разбиваются на семантические чанки,

каждому чанку присваивается chunk_id = "{doc_id}_{chunk_index}".

2.2 Вопросы (queries)

Источник: kaengreg/rubq (subset queries)

Содержимое:

естественно-языковые вопросы на русском,

часть вопросов имеет эталонные текстовые ответы.

2.3 Разметка релевантности (qrels)

Источник: kaengreg/rubq-qrels

Содержимое:

соответствие query-id → corpus-id,

указывает, какие документы корпуса релевантны конкретному вопросу.

Разметка qrels используется только для evaluation, не для обучения моделей.

3. Процесс формирования rubq_eval.jsonl

Файл формируется скриптом:

scripts/build_evalset_rubq.py

3.1 Основные шаги

Загружаются qrels:

формируется отображение
query-id → список релевантных corpus-id.

Загружаются вопросы (queries):

извлекается текст вопроса,

извлекаются эталонные ответы (если есть).

Для каждого вопроса:

если для него нет qrels, он отбрасывается,

формируется единая запись eval-датасета.

Все записи сохраняются в формате JSON Lines (.jsonl).

4. Формат файла

Файл rubq_eval.jsonl — это JSONL,
каждая строка — один независимый eval-пример.

4.1 Общая структура записи
{
  "qid": "string",
  "question": "string",
  "answers": ["string", "..."],
  "gold_doc_ids": ["string", "..."]
}

4.2 Описание полей
qid

Тип: string

Уникальный идентификатор вопроса

Соответствует query-id из qrels

Используется для:

логирования,

сопоставления ошибок,

анализа результатов по конкретным вопросам.

question

Тип: string

Текст вопроса на русском языке

Используется как вход в retrieval и generation.

Пример:

"question": "Кто совершил убийство, которое спровоцировало Первую мировую войну?"

answers

Тип: List[str]

Список допустимых эталонных ответов

Особенности:

может быть пустым ([]), если в исходном датасете нет ответа,

используется только для оценки качества генерации (EM / F1),

не используется для retrieval-метрик.

Пример:

"answers": ["Гаврило Принцип"]

gold_doc_ids

Тип: List[str]

Список идентификаторов документов корпуса, релевантных вопросу

Важно:

соответствует doc_id из корпуса,

не chunk_id,

используется для retrieval-метрик.

Пример:

"gold_doc_ids": ["123", "456"]

5. Связь с чанками

В проекте retrieval работает на уровне чанков, а qrels размечены на уровне документов.

Связь осуществляется так:

chunk_id = "{doc_id}_{chunk_index}"


Пример:

doc_id = "123"
chunk_id = "123_7"


При evaluation:

из chunk_id извлекается doc_id,

проверяется попадание doc_id в gold_doc_ids.

Это позволяет:

корректно оценивать retrieval на chunk-level,

не требовать ручной chunk-level разметки.

6. Использование в evaluation
6.1 Retrieval evaluation

Файл используется для расчёта:

Recall@k — попал ли хотя бы один релевантный документ в top-k,

MRR@k — насколько высоко был найден первый релевантный документ.

Используется в:

scripts/eval_retrieval.py

6.2 Answer evaluation (позже)

Поле answers используется для:

Exact Match (EM),

Token-level F1,

после генерации ответа моделью.

Используется в:

rag/metrics_qa.py

7. Ограничения датасета

Разметка релевантности документная, а не chunk-level.

Возможны вопросы:

с несколькими релевантными документами,

требующие multi-hop reasoning.

Не все вопросы имеют эталонные ответы.

Это делает датасет подходящим для исследования, но не для строгого production benchmarking.